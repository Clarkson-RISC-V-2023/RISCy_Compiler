import argparse
import sys

parser = argparse.ArgumentParser(prog="gpp", description="RISCV Post-Processor")
parser.add_argument("filename", type=str, help="input filename")
parser.add_argument("-i", type=str, help="instruction lib name")
parser.add_argument("-o", type=str, help="filename of output file")
parser.add_argument("-w", action="store_true", help="supress warnings")

args = parser.parse_args()

warning_flag = args.w

if args.o != None:
    output_file = args.o
else:
    output_file = "a.out"


input_file = args.filename

instr_lib = "instruction_lib.txt"

if args.i != None:
    instr_lib = args.i
else:
    instr_lib = "instruction_lib.txt"
supported_instr = ""
with open(instr_lib, "r") as f:
    supported_instr = f.readlines()


for i in range(len(supported_instr)):  # Removing \n on supported instructions
    supported_instr[i] = supported_instr[i].replace("\n", "")


file_data = ""
with open(input_file, "r") as f:
    file_data = f.readlines()

mark_start = 0
mark_end = 0
for i in range(len(file_data)):
    if "Disassembly of section .text:" in file_data[i]:
        mark_start = i + 1
    if "Disassembly of section .comment:" in file_data[i]:
        mark_end = i
        break

actual_data = file_data[mark_start:mark_end]
instructions = []
for item in actual_data:
    result = item.split(":")

    if len(result) >= 2 and result[1] != "\n":
        instruc_name = result[1][10:].split()
        if instruc_name[0] in supported_instr:
            instruction = result[1][1:9]
            
            

            instructions = instructions + [
                bin(int(instruction, 16))[2:].zfill(32)
            ]
            
        elif warning_flag != None:
            print('\033[93m' + "WARNING: Removed instruction \"" + instruc_name[0] + "\" at " + result[0].strip() + '\033[0m', file=sys.stderr)
            print(instruc_name)


with open(output_file, "w") as f:
    f.writelines("\n".join(instructions))
    f.close()
